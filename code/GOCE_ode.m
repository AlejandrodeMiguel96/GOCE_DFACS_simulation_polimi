function df = GOCE_ode(~, xx, data, failure, failure_valv)

% Integrates the set of differential equations that model the Drag Free and
% Attitude Control System (DFACS) of the GOCE project.
%
% INPUT:
% xx [vector 1x12]          Vector of variables.
% data [struct]             Structure with all the data necessary.
% failure [bool]            Boolean with value 0 if there is no engine
%                           failure, 1 otherwise.
% failure_valv [bool]       Boolean with value 0 if there is no valve
%                           failure, 1 otherwise.
%
% OUTPUT:
% df [vector 1x12]          Vector of the solution variables.
%
% 
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% Authors: Alejandro de Miguel, Rafael Felix, Carmen Salas
% Last modification: 15/01/2020
% Politecnico di Milano, Modeling and Simulation of Aerospace Systems
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Variables

a     = xx(1);
e     = xx(2);
i     = xx(3);
% O     = xx(4);
o     = xx(5);
nu    = xx(6);
xa    = xx(7);
va    = xx(8);
Vout  = xx(9);
xvalv = xx(10);
vvalv = xx(11);
I     = xx(12);

if failure_valv == 1
    vvalv = 0;
end

%% Orbital and cartesian elements

[rr_sc, vv_sc] = kep2car(xx(1:6), data.muE);

rr = rr_sc';
vv = vv_sc';
r  = norm(rr);

%% Perturbing acceleration in cartesian coordinates (aap_car)

% J2 PERTURBATION

J2    = 0.00108263;   
Re    = data.Re;
ax_j2 = 3/2 * J2*data.muE*Re^2/r^4 * (rr(1)/r * (5*rr(3)^2/r^2 - 1));
ay_j2 = 3/2 * J2*data.muE*Re^2/r^4 * (rr(2)/r * (5*rr(3)^2/r^2 - 1));
az_j2 = 3/2 * J2*data.muE*Re^2/r^4 * (rr(3)/r * (5*rr(3)^2/r^2 - 3));
aa_j2 = [ax_j2; ay_j2; az_j2];                                              % Acceleration vector due to J2

% AIR DRAG PERTURBATION
r_earth = radius_earth(data.ra, data.rc, rr);
height  = r - r_earth;
rho     = atm_model(height);

vv_rel = vv - cross(data.ww_earth, rr);
v_rel  = norm(vv_rel);

A_sc       = data.A*1e-6;                                                   % Frontal area [km^2]
D          = 0.5*A_sc*data.cd*rho*v_rel^2*vv_rel/v_rel;                     % Drag force modulus [kg*km/s^2]
a_drag_sc  = -D/data.M;                                                     % Spacecraft's drag acceleration modulus [km/s]
aa_drag_sc = a_drag_sc';                                                    % Acceleration vector due to air drag

D_sc = dot(D,vv)/norm(vv);

% BOUNDARY CONDITIONS
xvalv_max =  data.A0*10;
xvalv_min =  0;

% THRUST ACCELERATION

alpha  = 2*pi - 2*acos(1 - 2*xvalv/10/data.A0);                             % Angle defining geometry
A_valv = data.A0*(alpha - sin(alpha))/2/pi;                                 % Area varying as a circular conduct being opened

if xvalv > 10*data.A0                                                       % To avoid propagation of complex numbers due to
    A_valv = 0;                                                             % xvalve surpassing the limit, the area is controlled
elseif xvalv < 0                                                            % at both the upper and lower limits
    A_valv = data.A0;
end

mdot   = data.cdis*A_valv*sqrt(2/data.R/data.T2*data.k/(data.k - 1))*...    % Mass flow rate (choked)
         data.p2*sqrt((2/(data.k + 1))^(2/(data.k - 1)) - (2/(data.k + ...
         1))^((data.k + 1)/(data.k - 1)));
     
if failure == 1
    T = 0;                                                                  % Failure: thruster not working (T=0)
else
    T = mdot*sqrt(2*data.e*data.DV/data.m_i);                               % Thrust generated by the ion thruster [N]
end

a_thrust  = T/data.M * 1e-3;                                                % [km/s^2]
aa_thrust = a_thrust * vv_rel/norm(vv_rel);
aa_thrust = aa_thrust';

%% Components of the perturbing acceleration [at,an,ah]

t     = vv/norm(vv);
hh    = cross(rr, vv);
h0    = hh/norm(hh);
n0    = cross(h0, t);
A_mat = [t; n0; h0];

aa_j2_tnh = A_mat*aa_j2;                                                   % J2 perturbation in tangent, normal and 
                                                                            % angular momentum coordinates

aa_sc = aa_j2_tnh + aa_drag_sc + aa_thrust;                                 % Total perturbation acceleration

at_sc = aa_sc(1);
an_sc = aa_sc(2);
ah_sc = aa_sc(3);

%% Differential equations

% Useful parameters
b0     = a*sqrt(1 - e^2);
p0     = b0^2/a;
n0     = sqrt(data.muE/a^3);
h0     = n0*a*b0;
r0     = p0/(1 + e*cos(nu));
theta0 = nu + o;
v0     = sqrt(2*data.muE/r0 - data.muE/a);

% ORBITAL MECHANICS

df(1,1) = 2*a^2*v0/data.muE*at_sc;                                          % a
df(2,1) = 1/v0*(2*(e + cos(nu))*at_sc - r0/a*sin(nu)*an_sc);                % e
df(3,1) = r0*cos(theta0)/h0*ah_sc;                                          % i
df(4,1) = r0*sin(theta0)/(h0*sin(i))*ah_sc;                                 % O
df(5,1) = 1/(e*v0)*(2*sin(nu)*at_sc + (2*e + r0/a*cos(nu))*an_sc) - ...     % o
          r0*sin(theta0)*cos(i)/(h0*sin(i))*ah_sc;
df(6,1) = h0/r0^2 - 1/(e*v0)*(2*sin(nu)*at_sc + (2*e + r0/a*cos(nu))*...    % nu
          an_sc); 


% ACCELEROMETER

Vout_dot = -1/data.Cf*2*data.ep*data.Aa*(data.g^2 + xa^2)/(data.g^2 - ...   % d(Vout)/d(t)
            xa^2)^2*va*data.Vbias;

Vx = xa/data.g*data.Vbias;                                                  % Voltage generated by rotor
Vc = data.Kpa*Vout + data.Kda*Vout_dot;                                     % Control voltage     

DV1 = data.Vbias - Vc - 0.5*Vx;                                             % Increment of V at stator 1
DV2 = data.Vbias + Vc + 0.5*Vx;                                             % Increment of V at stator 2

Fe1 = 0.5*data.ep*data.Aa*DV1^2/(data.g - xa)^2;                            % Electric force exerted by stator 1
Fe2 = 0.5*data.ep*data.Aa*DV2^2/(data.g + xa)^2;                            % Electric force exerted by stator 2

D_acc = D_sc/data.M    *1e3*data.m;                                         % Drag exerted upon the accelerator [N]
T_acc = norm(a_thrust) *1e3*data.m;                                         % Thrust exerted upon the accelerator [N]

df(7,1) = va;                                                               % d(xa)/d(t)
df(8,1) = 1/data.m*(T_acc - D_acc - Fe1 + Fe2);                             % d(va)/d(t)
df(9,1) = Vout_dot;                                                         % d(Vout)/d(t)

% CONTROL VALVE

df(10,1) = vvalv;                                                           % d(xvalv)/d(t)
df(11,1) = 1/data.m_fcv*(data.Kfcv*(10*data.A0 - xvalv) - data.Ki*I - ...   % d(vvalv)/d(t)
            data.c*vvalv);
df(12,1) = data.Kpv*Vout_dot  + data.Kiv*Vout;                              % d(I)/d(t)

% Failure mode: valve not working (blocked)
if failure_valv == 1
    df(10,1) = 0;
    df(11,1) = 0;
end

if xvalv >= xvalv_max && df(11) > 0                                         % If maximum valve stroke is reached and acceleration
    df(11) = 0;                                                             % is positive, acceleration must be zero (no 
end                                                                         % discontinuity is introduced in the variables, only
                                                                            % in their derivatives)
if xvalv <= xvalv_min && df(11) < 0
    df(11) = 0;
end

end